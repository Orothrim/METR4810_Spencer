#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/background_segm.hpp>
#include "iostream"
#include <ctime>
#include <stdio.h>
#include <unistd.h>     // UNIX standard function definitions
#include <fcntl.h>      // File control definitions
#include <errno.h>      // Error number definitions
#include <termios.h>    // POSIX terminal control definitions
#include "/home/swift/code/customfunctions/DisplayFrames.h"


// #define DEBUG

#define AREA_THRESH 200

//Cropped area size.
#define SQUARE_SIZE 200
#define CROPMIDPOINT 100

//Marker relations
#define BLUE_DIST 350
#define RED_DIST 500
//Red Marker Position
#define RED_X BLUE_DIST/2
#define RED_Y RED_DIST
//Right Most Blue Marker Position
#define BLUE_X_1 0
#define BLUE_Y_1 0
//Left Most Blue Marker Position
#define BLUE_X_2 BLUE_DIST
#define BLUE_y_2 0

#define ELEMENT_TYPE 2
#define OPENING_SIZE 2
#define CLOSING_SIZE 2

//Used to access all of the images.
#define ONESCOLUMN 6
#define TENSCOLUMN 5
#define NUMIMAGES 16

//Middle point of images.
#define MIDDLEX 292
#define MIDDLEY 360

//Colours used in image analysis.
#define WHITE 255
#define MANICOLOUR 127

//Size of the images when displayed.
#define WINDOWX 500
#define WINDOWY 400

using namespace cv;
using namespace std;

Point brightLoc, mousePos;

char input;
int cnt = 0, i, brightness = 0, largestIndex, secondIndex, intense, eleType, redIndex, blueIndex1, blueIndex2;

double largestArea, secondArea, area, distBlue;

Mat openElement, closeElement;
Rect bRect;
Scalar intenseAvg, yuvColour, color[3], yuvAvg;

vector<vector<Point> > contours;
// vector<Point2f> positions;
vector<Vec4i> hierarchy;

Point2f bluePos1, bluePos2, redPos1, diff;

Mat originalFrame, frame, threshImage, erodedImage, colourImages[3], yuvImage, yuvSplit[3], contoursImage, blueImage, redImage, brightImage, mogFrame, maskImage;
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
// Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;

int USB = open( "/dev/rfcomm0", O_RDWR| O_NOCTTY );

//Function Prototypes

void onMouse(int event, int x, int y, int flags, void* userdata);
int write(char message[10]);
void processVideo(char* videoFilename);

int main(int argc, char* argv[])
{
	//check for the input parameter correctness
	// if(argc != 3) {
	// 	cerr <<"Incorret input list" << endl;
	// 	cerr <<"exiting..." << endl;
	// 	return EXIT_FAILURE;
	// }

	if( ELEMENT_TYPE == 0 ){ eleType = MORPH_RECT; }
	else if( ELEMENT_TYPE == 1 ){ eleType = MORPH_CROSS; }
	else if( ELEMENT_TYPE == 2) { eleType = MORPH_ELLIPSE; }

	openElement = getStructuringElement(eleType , Size( 2*OPENING_SIZE + 1, 2*OPENING_SIZE+1 ), Point(OPENING_SIZE, OPENING_SIZE));
	closeElement = getStructuringElement(eleType , Size( 2*CLOSING_SIZE + 1, 2*CLOSING_SIZE+1 ), Point(CLOSING_SIZE, CLOSING_SIZE));

	#ifdef DEBUG
	cout << "Elements Created\n\r";
	#endif

	color[0] = Scalar(255, 0, 0);
	color[1] = Scalar(0, 0, 255);
	color[2] = Scalar(255, 255, 255);

	pMOG= new BackgroundSubtractorMOG(); //MOG approach
	// pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach

	VideoCapture cap(1);     // get 'any' cam
	while( cap.isOpened() )   // check if we succeeded
	{
		Mat frame;
		if ( ! cap.read(frame) )
			break;

		// cap.set(21, 0);
		// cap.set(15, 1);


		#ifdef DEBUG
		cout << "Frame taken\n\r";
		#endif
		//update the background model
			//AND HERE!!!
		pMOG->operator()(frame, fgMaskMOG);

		originalFrame = frame.clone();

		//Processing on frame.
		cvtColor(frame, frame, CV_BGR2YCrCb);
		yuvAvg = mean(frame);
		split(frame, yuvSplit);

		threshold(yuvSplit[0], brightImage, yuvAvg[0]*1.2, 255, THRESH_BINARY);
		threshold(yuvSplit[1], redImage, yuvAvg[1]*1.1, 255, THRESH_TOZERO);
		threshold(yuvSplit[2], blueImage, yuvAvg[2]*1.1, 255, THRESH_TOZERO);

		#ifdef DEBUG 
		cout << "Image split\n\r";
		#endif

		bitwise_and(brightImage, fgMaskMOG, maskImage);
		dilate(maskImage, maskImage, closeElement);

		// disImage((char *)"Mask Image", maskImage, 1);
		// disImage((char *)"FG Mask MOG2", fgMaskMOG2, 2);

		cnt++;
		// pMOG2->operator()(frame, fgMaskMOG2);
		//get the frame number and write it on the current frame

		//show the current frame and the fg masks
		// dilate(fgMaskMOG, fgMaskMOG, closeElement);
		// mogFrame = Mat::zeros(frame.size(), CV_8UC1);
		// frame.copyTo(mogFrame, fgMaskMOG);

		#ifdef DEBUG 
		cout << "Background mask dilated\n\r";
		#endif
		

		//White lights should be reduced, as the markers are distinct colours.
		// colourImages[0] = blueImage; // - redImage*0.3;
		// colourImages[1] = redImage; // - blueImage*0.3;

		// disImage((char *)"Bright", brightImage, 4);
		// disImage((char *)"Blue Image 1", blueImage, 2);
		// disImage((char *)"Red Image 1", redImage, 5);

		bitwise_and(blueImage, maskImage, colourImages[0]);
		// blueImage.copyTo(colourImages[0], brightImage);

		bitwise_and(redImage, maskImage, colourImages[1]);
		// redImage.copyTo(colourImages[1], brightImage);

		#ifdef DEBUG
		cout << "Brightness mask applied\n\r";
		#endif

		for(int k = 0; k <= 1; k++) {
			#ifdef DEBUG
			if (k == 0) {
				disImage((char *)"Blue Image 2", colourImages[0], 2);
			}
			else {
				disImage((char *)"Red Image 2", colourImages[1], 5);
			}
			#endif

			intenseAvg = mean(colourImages[k]);
			// threshold(colourImages[k], threshImage, 0, 255, THRESH_BINARY | THRESH_OTSU);
			threshold(colourImages[k], threshImage, intenseAvg[0], 255, THRESH_BINARY);

			erode(colourImages[k], erodedImage, openElement);
			dilate(erodedImage, threshImage, openElement);

			contoursImage = threshImage.clone();

			blur(contoursImage, contoursImage, Size(4,4));

			findContours(contoursImage, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0,0));

			#ifdef DEBUG 
			cout << "Contours found\n\r";
			if (k == 0) {
				disImage((char *)"Blue Image 3", threshImage, 3);
			}
			else {
				disImage((char *)"Red Image 3", threshImage, 6);
			}
			#endif

			vector<Point2f> positions( contours.size() );
			vector<Moments> mu(contours.size() );

			largestArea = 0;
			secondArea = 0;
			area = 0;
			largestIndex = 0;
			for(int i = 0; i<contours.size(); i++) {
				mu[i] = moments( contours[i], false );
				area = contourArea(contours[i], false);
				positions[i] = Point2f( mu[i].m10/mu[i].m00 , mu[i].m01/mu[i].m00 );
				if(area > AREA_THRESH) {
					if(area > largestArea) {
						largestArea = area;
						largestIndex = i;
					}
					else if(area > secondArea) {
						secondIndex = i;
						secondArea = area;
					}
				}
			}
			if (largestArea > 0) {
				bRect = boundingRect(contours[largestIndex]);
				rectangle(originalFrame, bRect, color[k]);
				if (k) {
					redPos1 = positions[largestIndex];
				}
				else {
					if (secondArea  > 0) {
						bluePos1 = positions[largestIndex];
						bluePos2 = positions[secondIndex];
						diff = bluePos1 - bluePos2;
						distBlue = sqrt(diff.x*diff.x + diff.y*diff.y);

						stringstream ss;
						rectangle(frame, Point(10, 2), Point(100,20), Scalar(255,255,255), -1);
						ss << distBlue;
						string frameNumberString = ss.str();
						putText(originalFrame, frameNumberString.c_str(), Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5 , Scalar(0,0,0));
					}
				}
			}

			// cout << "Red Position : " << 
			if (secondArea > 0) {
				bRect = boundingRect(contours[secondIndex]);
				rectangle(originalFrame, bRect, color[k]);
			}
		}

		disImage((char *)"Frame", originalFrame, 1);

		int k = waitKey(33);
		if ( k==27 )
			break;
	}
	return 0;

	destroyAllWindows();
	return EXIT_SUCCESS;
}
