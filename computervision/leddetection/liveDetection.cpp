#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/background_segm.hpp>
#include "iostream"
#include <ctime>
#include <stdio.h>
#include <unistd.h>     // UNIX standard function definitions
#include <fcntl.h>      // File control definitions
#include <errno.h>      // Error number definitions
#include <termios.h>    // POSIX terminal control definitions
#include "/home/swift/code/customfunctions/DisplayFrames.h"
#include "/home/swift/code/customfunctions/BlueRFcomm.h"

#define DISPLAY 1
#define DEBUG 0
#define STATE_MACHINE 1
#define LINES 0

#define AREA_THRESH 200

//Cropped area size.
#define SQUARE_SIZE 200
#define CROPMIDPOINT 100

//Marker relations
#define BLUE_DIST 375
#define RED_DIST 500
//Red Marker Position
#define RED_X BLUE_DIST/2
#define RED_Y RED_DIST
//Right Most Blue Marker Position
#define BLUE_X_1 0
#define BLUE_Y_1 0
//Left Most Blue Marker Position
#define BLUE_X_2 BLUE_DIST
#define BLUE_y_2 0

#define ELEMENT_TYPE 2
#define OPENING_SIZE 2
#define CLOSING_SIZE 2

//Projective Geometry 
#define LAMBDA 1000/250
#define FOCAL_LENGTH 680

//Size of the images when displayed.
#define WINDOWX 500
#define WINDOWY 400

using namespace cv;
using namespace std;

Point brightLoc, mousePos;

char input;
int cnt = 0, i, highestIndex, secondIndex, intense, eleType, redIndex, blueIndex1, blueIndex2, state = 0, newState = 0;
int8_t data, midCalc;

double highestInt, secondInt, area, distBlue;

Mat openElement, closeElement;
Rect bRect;
Scalar intenseAvg, yuvColour, color[3], yuvAvg;

vector<vector<Point> > contours;
// vector<Point2f> positions;
vector<Vec4i> hierarchy;

Point2f bluePos1, bluePos2, redPos1, diff, midPoint;

Mat originalFrame, frame, threshImage, erodedImage, colourImages[3], yuvImage, yuvSplit[3], contoursImage, blueImage, redImage, brightImage, mogFrame, maskImage;
Mat fgMaskMOG; //fg mask generated by MOG method
// Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
// Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;

// int USB = open( "/dev/rfcomm0", O_RDWR| O_NOCTTY );

//Function Prototypes

void onMouse(int event, int x, int y, int flags, void* userdata);
void processVideo(char* videoFilename);

int main(int argc, char* argv[])
{
	//check for the input parameter correctness
	// if(argc != 3) {
	// 	cerr <<"Incorret input list" << endl;
	// 	cerr <<"exiting..." << endl;
	// 	return EXIT_FAILURE;
	// }

	if( ELEMENT_TYPE == 0 ){ eleType = MORPH_RECT; }
	else if( ELEMENT_TYPE == 1 ){ eleType = MORPH_CROSS; }
	else if( ELEMENT_TYPE == 2) { eleType = MORPH_ELLIPSE; }

	openElement = getStructuringElement(eleType , Size( 2*OPENING_SIZE + 1, 2*OPENING_SIZE+1 ), Point(OPENING_SIZE, OPENING_SIZE));
	closeElement = getStructuringElement(eleType , Size( 2*CLOSING_SIZE + 1, 2*CLOSING_SIZE+1 ), Point(CLOSING_SIZE, CLOSING_SIZE));

	#if DEBUG
	cout << "Elements Created\n\r";
	#endif

	color[0] = Scalar(255, 0, 0);
	color[1] = Scalar(0, 0, 255);
	// color[2] = Scalar(255, 255, 255);

	pMOG= new BackgroundSubtractorMOG(); //MOG approach
	// pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach

	VideoCapture cap(1);     // get 'any' cam

	cnt = 0;
	while( cap.isOpened() && cnt < 100 ) {

		Mat frame;
		if ( ! cap.read(frame) ) {
			break;
		}
		disImage((char *)"Frame", frame, 1);
		cnt++;

		int k = waitKey(33);
		if ( k==27 )
			break;
	}


	#if DEBUG
	cout << "Sleep Finished\n\r";
	#endif

	while( cap.isOpened() )   // check if we succeeded
	{
		Mat frame;
		if ( ! cap.read(frame) ) {
			break;
		}

		// bluePos2 = Scalar(0;
		// bluePos1 = 0;
		// redPos1 = 0;

		// cap.set(21, 0);
		// cap.set(15, 1);


		#if DEBUG
		cout << "Frame taken\n\r";
		#endif
		//update the background model
			//AND HERE!!!
		pMOG->operator()(frame, fgMaskMOG);

		originalFrame = frame.clone();

		//Processing on frame.
		cvtColor(frame, frame, CV_BGR2YCrCb);
		yuvAvg = mean(frame);
		split(frame, yuvSplit);

		threshold(yuvSplit[0], brightImage, yuvAvg[0]*1.2, 255, THRESH_BINARY);
		threshold(yuvSplit[1], redImage, yuvAvg[1]*1.1, 255, THRESH_TOZERO);
		threshold(yuvSplit[2], blueImage, yuvAvg[2]*1.1, 255, THRESH_TOZERO);

		#if DEBUG 
		cout << "Image split\n\r";
		#endif

		bitwise_and(brightImage, fgMaskMOG, maskImage);
		dilate(maskImage, maskImage, closeElement);

		disImage((char *)"Mask Image", maskImage, 1);
		// disImage((char *)"FG Mask MOG2", fgMaskMOG2, 2);

		cnt++;
		// pMOG2->operator()(frame, fgMaskMOG2);
		//get the frame number and write it on the current frame

		//show the current frame and the fg masks
		// dilate(fgMaskMOG, fgMaskMOG, closeElement);
		// mogFrame = Mat::zeros(frame.size(), CV_8UC1);
		// frame.copyTo(mogFrame, fgMaskMOG);

		#if DEBUG 
		cout << "Background mask dilated\n\r";
		#endif
		

		//White lights should be reduced, as the markers are distinct colours.
		bitwise_and(blueImage, maskImage, colourImages[0]);
		// blueImage.copyTo(colourImages[0], brightImage);

		bitwise_and(redImage, maskImage, colourImages[1]);
		// redImage.copyTo(colourImages[1], brightImage);

		#if DEBUG
		cout << "Brightness mask applied\n\r";
		#endif

		for(int i = 0; i <= 1; i++) {
			#if DEBUG
			if (i == 0) {
				disImage((char *)"Blue Image 2", colourImages[0], 2);
			}
			else {
				disImage((char *)"Red Image 2", colourImages[1], 5);
			}
			#endif

			intenseAvg = mean(colourImages[i]);
			// threshold(colourImages[i], threshImage, 0, 255, THRESH_BINARY | THRESH_OTSU);
			threshold(colourImages[i], threshImage, intenseAvg[0], 255, THRESH_BINARY);

			erode(colourImages[i], erodedImage, openElement);
			dilate(erodedImage, threshImage, openElement);

			contoursImage = threshImage.clone();

			blur(contoursImage, contoursImage, Size(4,4));

			findContours(contoursImage, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0,0));

			#if DEBUG 
			cout << "Contours found\n\r";
			if (i == 0) {
				disImage((char *)"Blue Image 3", threshImage, 3);
			}
			else {
				disImage((char *)"Red Image 3", threshImage, 6);
			}
			#endif

			vector<Point2f> positions( contours.size() );
			vector<Moments> mu(contours.size() );

			highestInt = 0;
			secondInt = 0;
			area = 0;
			highestIndex = 0;
			secondIndex = 0;

			Mat labels = Mat::zeros(frame.size(), CV_8UC1);

			for(int j = 0; j<contours.size(); j++) {
				mu[j] = moments( contours[j], false );
				area = contourArea(contours[j], false);

				drawContours(labels, contours, j, Scalar(j), CV_FILLED);
				bRect = boundingRect(contours[j]);
				Scalar intenseAvg = mean(frame(bRect), labels(bRect) == j);
				// cont_avgs[j] = mean[0];

				if (intenseAvg[0] > highestInt) {
					secondInt = highestInt;
					secondIndex = highestIndex;

					highestInt = intenseAvg[0];
					highestIndex = j;
				}
				else if(intenseAvg[0] > secondInt) {
					secondInt = intenseAvg[0];
					secondIndex = j;
				}

				positions[j] = Point2f( mu[j].m10/mu[j].m00 , mu[j].m01/mu[j].m00 );
				// if(area > AREA_THRESH) {
				// 	if(area > largestArea) {
				// 		largestArea = area;
				// 		largestIndex = j;
				// 	}
				// 	else if(area > secondArea) {
				// 		secondIndex = j;
				// 		secondArea = area;
				// 	}
				// }
			}
			if (highestInt > 0) {
				if (i) {
					redPos1 = positions[highestIndex];
				}
				else {
					if (secondInt  > 0) {
						if(positions[highestIndex].x < positions[secondIndex].x) {
							bluePos1 = positions[highestIndex];
							bluePos2 = positions[secondIndex];
						} else {
							bluePos1 = positions[secondIndex];
							bluePos2 = positions[highestIndex];	
						}
						diff = bluePos1 - bluePos2;
						distBlue = sqrt(diff.x*diff.x + diff.y*diff.y);

						stringstream ss;
						rectangle(frame, Point(10, 2), Point(100,20), Scalar(255,255,255), -1);
						ss << distBlue;
						string frameNumberString = ss.str();
						cout << distBlue << endl;
						putText(originalFrame, frameNumberString.c_str(), Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5 , Scalar(0,0,0));

						//Dâ€™ = (W x F) / P
						//D = distance
						//W = Width
						//F = Focal Length
						//P = Pixel Length
						dist = (BLUE_DIST*FOCAL_LENGTH)/distBlue;



						//Two versions of the code exist, one merely conveys a state change to the glider, informing it to turn left (1), turn right (2), angle left (3), angle right (4) or continue straight (0).  The second version gets the relative positions and sends a data packet of the position relative to the desired position.
						midPoint.x = (bluePos1.x + bluePos2.x)/2;
						midPoint.y = (bluePos1.y + bluePos2.y)/2;

						midCalc = (int)((midPoint.x)*20/(frame.cols));

						blueSlope = (bluePos2.y - bluePos1.y)/(bluePos2.x - bluePos1.x);
						redSlope = (midPoint.y - redPos1.y)/(midPoint.x - redPos1.x);

						#if DISPLAY						
						line(originalFrame, bluePos1, bluePos2, color[0]);
						line(originalFrame, midPoint, redPos1, color[1]);
						#endif

						#if STATE_MACHINE
						if(-1 > midPoint) {
							newState = 1;
						} else if(midPoint > 1) {
							newState = 2;
						} else {
							newState = 0;
						}

						if(!(state == newState)) {
							writeRFcomm(newState);
							state = newState;
						}
						#else
						
						#endif


						// switch (state) {
						// 	case 0:
						// 		writeRFcomm((char *)"t");
						// 		state = newState;
						// 		break;
						// 	case 0:
						// 		writeRFcomm((char *)"t");
						// 		state = newState;
						// 		break;
						// 	case 0:
						// 		writeRFcomm((char *)"t");
						// 		state = newState;
						// 		break;

						}
					}
				}
			}

			// cout << "Red Position : " << 
		}
		#if DISPLAY
		disImage((char *)"Frame", originalFrame, 1);
		#endif

		int k = waitKey(33);
		if ( k==27 )
			break;
	}
	return 0;

	destroyAllWindows();
	return EXIT_SUCCESS;
}
